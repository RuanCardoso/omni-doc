{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Omni Network","text":""},{"location":"#what-is-omni-network","title":"What is Omni Network?","text":"<p>Omni is a Unity framework created with a strong focus on achieving high-performance in the development of multiplayer games. Its main focus is to provide a set of tools and infrastructure that will make it easier for developers to create high-quality, responsive, and scalable multiplayer experiences.</p>"},{"location":"#how-does-omni-differ-from-other-frameworks","title":"How does Omni differ from other frameworks?","text":"<p>Omni has a number of features that set it apart from other frameworks. One of the main advantages is that it provides a high level of control over the networking infrastructure, allowing developers to optimize their networking code for maximum performance. Additionally, Omni provides a number of features that are not typically found in other multiplayer frameworks, such as:</p> <ul> <li>Built-in ORM: Omni comes with a built-in ORM similar to Entity Framework, which supports a wide range of databases, such as MySQL, MariaDB, PostgreSQL, SQLite, SQL Server, Oracle, Firebird, and others. Forget about PHP or any other backend language, do everything from your own game server, incredible, right? </li> <li>Decoupling: Omni allows you to decouple your game servers from other services like databases, authentication servers, and even game clients, allowing you to work with the design of Micro-Services, for example, you can have the database server independent from your game server and deploy it in a different server from your game server.</li> <li>Message Serialization: Omni supports message serialization using extremely efficient serializers like MemoryPack and MessagePack, and also supports communication via JSON for ease of use. Also, it offers message compression capabilities, which can significantly reduce the amount of data being sent over the network, resulting in faster data transfer and lower network bandwidth usage.</li> <li>Transport providers: Omni supports a wide range of transport providers out of the box, such as TCP, UDP, WebSocket, and it comes bundled with some providers that have multiple layers, like Reliable, Unreliable, ReliableEncrypted, etc. The encryption is top-notch and securely implemented using AES and RSA, providing a highly secure and efficient solution for your multiplayer game's security needs.</li> <li>Any type of data: Omni can serialize any type of data, such as classes, structs, lists, dictionaries, primitives, etc., making it a versatile tool for any kind of application that requires data serialization.</li> <li>Web Server: Omni comes with an embedded web server based on nginx, allowing you to create RESTful APIs, webhooks, and web applications directly from your game server, without the need to create a separate web server or deploy a backend application.</li> <li>Routing: Omni comes with a routing system similar to Express.js for Node.js, allowing you to create RESTful APIs, webhooks, and web applications directly from your game server.</li> <li>Additionally, Omni has many other features and capabilities that make it a powerful tool for any multiplayer game developer, such as support for RPC, NetVars, Web Sockets, Unity WebGL, Streamlined HTTP Handling, Port Forwarding, etc... allowing you to create high-quality, responsive, and scalable multiplayer experiences.</li> </ul> <p>These features, along with its high performance and flexibility, make Omni a powerful choice for any multiplayer game developer looking to create a high-quality, responsive, and scalable multiplayer experience.</p> <p>Hire me, my email is cardoso.ruan050322@gmail.com</p>"},{"location":"Communication/rpc/","title":"Communication","text":""},{"location":"Communication/rpc/#remote-procedure-call","title":"Remote Procedure Call","text":"<p><code>RPC (Remote Procedure Call)</code> in games is an essential concept in network programming, used to synchronize actions between players and the server. When a player performs an action, such as moving their character, that action is sent to the server via an <code>RPC</code>, identifying the player involved. The server processes the action and distributes it to all other players in the same area of the game. Thus, <code>RPC</code> is closely tied to the player's identity, ensuring that actions are correctly attributed to the player who sent them, but on the devices of other players.</p> <p>The Omni offers two ways to create an <code>RPC</code>: using source generators or manually.</p> <p>Using Source Generators: <code>recommended</code></p> <p>Warning</p> <p>Note that when using source generators, the class must be marked as <code>partial</code> and inherit from <code>NetworkBehaviour</code>, the code is generated automatically.</p> <p>Attach the script below to an object that has the NetworkIdentity component. Assign the identity to the <code>identity</code> field of the script, which will be exposed in the inspector.</p> <pre><code>using Omni.Core;\nusing UnityEngine;\n\n[Remote(\"Move\")]\npublic partial class RpcTest : NetworkBehaviour\n{\n    // this method is generated automatically\n    partial void Move_Client(IDataReader reader, NetworkPeer peer)\n    {\n        // client side code, invoked when the client receives the RPC\n        Debug.Log(\"Move received: \" + IsServer);\n    }\n\n    // this method is generated automatically\n    partial void Move_Server(IDataReader reader, NetworkPeer peer)\n    {\n        // server side code, invoked when the server receives the RPC\n         Debug.Log(\"Move received: \" + IsServer);\n    }\n\n    // not generated automatically, only for example.\n    private void SendToServer()\n    {\n        // send from client to server\n        if (IsMine)\n        {\n            if (Input.GetKeyUp(KeyCode.Return))\n            {\n                MoveClientRpc(); // this method is generated automatically\n            }\n        }\n    }\n\n    // not generated automatically, only for example.\n    private void SendToClient()\n    {\n        // send from server to client\n        if (IsServer)\n        {\n            if (Input.GetKeyUp(KeyCode.Return))\n            {\n                MoveServerRpc(); // this method is generated automatically\n            }\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>The <code>Remote</code> attribute has two additional optional parameters: <code>Id</code> and <code>Self</code>.</p> <p><code>Id</code>: You can choose the ID that the generator will assign to the RPC method. The ID must be between 1 and 255.</p> <p><code>Self</code>: If set to true, the generator will generate only one RPC method instead of two separate methods for the server and the client. In this mode, <code>IsServer</code> should be used to differentiate the logic. eg:</p> <pre><code>[Remote(\"Move\", Id = 10, Self = true)]\npublic partial class CLITests : NetworkBehaviour\n{\n    partial void Move(IDataReader reader, NetworkPeer peer)\n    {\n        if (IsServer)\n        {\n            // server side code\n        }\n        else\n        {\n            // client side code\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>When invoking the RPC as shown in the example above, <code>MoveClientRpc()</code> and <code>MoveServerRpc()</code>, these calls have multiple overloads with optional parameters to customize the data transmission. eg:</p> <pre><code>public void SendToServer()\n{\n    IDataWriter parameters = new DataWriter();\n    parameters.Write(\"Ruan\");\n    MoveClientRpc(parameters, DeliveryMode.Unreliable, TargetMode.Broadcast, 0); // this method is generated automatically\n    // MoveClientRpc(parameters, DeliveryMode.ReliableEncryptedOrdered, TargetMode.Server, 0); // this method is generated automatically\n}\n</code></pre>"},{"location":"Communication/serialization/","title":"Communication","text":""},{"location":"Communication/serialization/#serialization","title":"Serialization","text":"<p>Omni functions leverage two interfaces, IDataWriter and IDataReader, which respectively serve as data writers and readers. These interfaces facilitate the serialization of any type of data for network transmission, enabling seamless communication.</p>"},{"location":"Communication/serialization/#primitives-structs","title":"Primitives &amp; Structs","text":"<pre><code>using Omni.Core;\nusing UnityEngine;\n\npublic class SerializationExample : MonoBehaviour\n{\n    private void Start()\n    {\n        IDataWriter data = new DataWriter();\n        data.Write(\"Hello World\");\n        data.Write(123);\n        data.Write(123.456f);\n        data.Write(123.456d);\n        data.Write(true);\n        data.Write(false);\n        data.Write(new Vector3(1, 2, 3));\n        data.Write(new Quaternion(1, 2, 3, 4));\n        data.Write(new Color(1, 2, 3, 4));\n        data.Write(new Color32(1, 2, 3, 4));\n\n        // pass the data to the Omni function..\n        // pseudo-code:\n        MoveClientRpc(data);\n    }\n}\n</code></pre>"},{"location":"Communication/serialization/#complex-types","title":"Complex Types","text":"<pre><code>using Omni.Core;\nusing UnityEngine;\n</code></pre>"},{"location":"Getting%20Started/components/","title":"Getting Started","text":""},{"location":"Getting%20Started/components/#port-forwarding","title":"Port Forwarding","text":"<ol> <li>Go to the <code>Hierarchy</code> tab, select and expand the <code>Omni Networking</code> game obect.</li> </ol> <p>This component facilitates port forwarding from your public IP address to your local game server. It requires the presence of either UPnP (Universal Plug and Play) or PMP (Port Mapping Protocol) in your router for proper operation. These protocols enable automatic configuration of port forwarding rules, ensuring seamless connectivity between external clients and your game server on the local network.</p> <p>Warning</p> <p>Make sure UPnP is enabled on your router. If not, check if PMP is supported, or manually configure port forwarding settings. Additionally, be aware that some ISPs (Internet Service Providers) may block certain ports commonly used for gaming, such as 22 (SSH), 3389 (RDP), 3306 (MySQL), 80 (HTTP), and 443 (HTTPS). Please note that port blocking policies may vary depending on your ISP.</p> <p>Warning</p> <p>If you are using the Unity Editor, ensure that the necessary ports are open for the Editor in your system firewall. If you are running a client or server built executable, ensure that the ports are open for the respective client or server executable in your system firewall. Otherwise, the connection will be rejected.</p> <p><code>Omni default ports:</code></p> Property Web Socket(Tcp) Tcp &amp; Udp(Lite) Web Server(Http/Tcp) Ntp Server(Udp) <code>Port</code> 7777 - 7778 7777 - 7778 8080 - 8443 1023-1025 <code>Host</code> localhost localhost localhost localhost <p> ready!</p> <p>Note</p> <p>If you have tried all possible solutions, ensured correct configuration, and port forwarding still does not work, it is likely that your ISP is blocking the ports, your router does not support port forwarding, or there are firewall issues. In such cases, consider attempting NAT Hole Punching as an alternative solution.</p>"},{"location":"Getting%20Started/components/#network-prefab-manager","title":"Network Prefab Manager","text":"<ol> <li>Go to the <code>Hierarchy</code> tab, select and expand the <code>Omni Networking</code> game obect and select the <code>Network Prefab Manager</code> component.</li> </ol> <p>In this component, you must register all objects that will be instantiated on the network, such as players. All networked objects must have the <code>NetworkIdentity</code> component to be considered network objects. You can register the prefab via script using <code>PrefabManager.RegisterPrefab</code> or <code>OmniNetwork.PrefabManager.RegisterPrefab</code></p> <p></p>"},{"location":"Getting%20Started/components/#network-monitor","title":"Network Monitor","text":"<p>TODO: Add Network Monitor DOC.</p>"},{"location":"Getting%20Started/components/#network-matchmaking","title":"Network Matchmaking","text":"<p>This component handles matchmaking, rooms, groups, interest management, and more. It is accessed via, eg: <code>Matchmaking.JoinChannel</code> or <code>OmniNetwork.Matchmaking.JoinChannel</code>\"</p>"},{"location":"Getting%20Started/components/#network-time","title":"Network Time","text":""},{"location":"Getting%20Started/components/#network-security-group","title":"Network Security Group","text":""},{"location":"Getting%20Started/installation/","title":"Getting Started","text":""},{"location":"Getting%20Started/installation/#installation","title":"Installation","text":"<p>Install necessary dependencies before starting your project.</p> <pre><code>com.unity.nuget.newtonsoft-json\n</code></pre> <p>How to install newtonsoft-json?</p> <ol> <li>Open the Unity Editor.</li> <li>Go to <code>Window &gt; Package Manager</code>.</li> <li>Click on the <code>+</code> button in the top-left corner of the Package Manager window.</li> <li>Press <code>Add package by name</code>.</li> <li>Enter <code>com.unity.nuget.newtonsoft-json</code> as the package name and press <code>Add</code> or <code>Enter</code>.</li> <li>Wait for the installation to complete.</li> </ol> <p>Note</p> <p>Before installing check if the package is already installed. some versions of Unity include the package <code>com.unity.nuget.newtonsoft-json</code> by default. By default, Omni uses binary serialization, but it can use JSON serialization as well. </p> <ul> <li> Newtonsoft.Json is installed.</li> </ul> <p>Install Omni:</p> <ol> <li>Go to the GitHub repository Releases and download the latest version.</li> <li>Go to <code>Assets &gt; Import Package &gt; Custom Package</code> and select the downloaded version and press <code>Import</code>.</li> <li>Wait for the installation to complete and scripts recompilation.</li> </ol> <p>Note</p> <p>After installation, note that the following macros will be automatically defined in your project:</p> <ul> <li><code>OMNI_DEBUG</code> Automatically activated for debugging purposes. This macro is enabled by default.</li> <li><code>OMNI_RELEASE</code> Should be used for production builds. This activates all possible optimizations.</li> <li><code>OMNI_SERVER</code> Automatically activated when building the project for server deployment (Dedicated Server mode).</li> </ul> <p>Omni most used namespaces:</p> <ul> <li><code>using Omni.Core;</code> Used to all networking related classes, including database classes.</li> <li><code>using Omni.Core.Hashing;</code> Provides hashing utilities.</li> <li><code>using Omni.Core.Web;</code> Provides web functionality, like as, Express.js, Web Server, HTTP Request, etc.</li> <li><code>using Omni.Core.IMatchmaking;</code> Provides matchmaking functionality, like as, Rooms, Groups, etc.</li> <li><code>using Omni.Execution;</code> Provides database query execution.</li> <li><code>using static Omni.Core.OmniNetwork;</code> Provides fast access to the Omni Network Script.</li> </ul> <ul> <li> Omni is installed.</li> </ul> <p>Wow!, now you can start your project </p>"},{"location":"Getting%20Started/installation/#setup-omni","title":"Setup Omni","text":"<ol> <li>Go to <code>Omni</code> in the Unity Menu, next to the <code>Window</code> menu and press <code>Setup</code></li> <li>Go to the <code>Hierarchy</code> tab, select and expand the <code>Omni Networking</code> game obect.</li> </ol> <p>Let's take a look at what each of these scripts and configurations are now. </p> <p>Tip</p> <p>You can skip this step if you want, as Omni comes pre-configured. Play with the default settings and see what happens.</p> Property Description <code>Production Mode</code> Enables or disables production mode. Production mode should be enabled when you are ready to deploy your game, ensuring a stable and optimized environment for end-users. <code>Guid</code> A unique identifier for the current game version. If the server's GUID differs from the client's GUID, the connection will fail, ensuring consistency and integrity between client and server versions. <code>Omni Network Script &gt; Context Menu &gt; Generate GUID</code> <code>Physics Mode</code> Defines the physics mode to be used. Use 2D mode for two-dimensional games and 3D mode for three-dimensional games, ensuring accurate simulation of physical behavior according to your game's needs. This option is only used to simulate physics in scenes automatically created by Omni. <code>Loop Mode</code> Specifies the loop mode to be utilized. Choose between Tick-Based or Realtime, determining the execution model for game updates. Tick-Based provides a consistent time interval, while Realtime operates according to the framerate. <p>Warning</p> <p>Tick-Based update method: <pre><code>// you must inherit from `NetworkBehaviour` or `RealtimeTickBasedSystem`. inherit from `NetworkBehaviour` is recommended.\n// these methods are not called in realtime mode.\npublic class TickExample : NetworkBehaviour\n{\n    public override void OnUpdateTick(ITickData tick)\n    {\n        // is called every tick\n    }\n\n    public override void OnUpdateTickStart(ITickData tick)\n    {\n        // is called on the first tick\n    }\n\n    public override void OnUpdateTickEnd(ITickData tick)\n    {\n        // is called on the last tick\n    }\n}\n</code></pre></p> <p>Realtime update method: <pre><code>// you must inherit from `NetworkBehaviour` or `RealtimeTickBasedSystem`. inherit from `NetworkBehaviour` is recommended.\npublic class TickExample : NetworkBehaviour\n{\n    // this method is not called in tick-based mode.\n    public override void OnUpdate()\n    {\n        // is called every frame\n        // the same as Update() which is called by Unity.\n    }\n\n    // or independent, called by Unity.\n    public void Update()\n    {\n        // is called every frame\n    }\n}\n</code></pre></p> Property Description <code>Connect Async</code> Initiates an asynchronous connection to the server. This method allows for non-blocking connection establishment, ideal for scenarios where responsiveness is crucial. <code>Transport Option</code> Specifies the transport protocol utilized for communication with the server. Options include TCP, UDP or Web Sockets. <code>UDP(Lite) is the default.</code> <p>Warning</p> <p>TCP Layer Availability: TCP transport supports the Reliable and reliable encrypted layers. If other layers are specified, they will be ignored, and the default Reliable layer will be utilized.</p> <p>WebSocket Layer Availability: Web-Socket transport supports the Reliable and reliable encrypted layers. Specifying other layers will be disregarded, and the default Reliable layer will be employed. Encryption can be enabled by installing an SSL certificate.</p> <p>UDP Layer Availability: UDP transport offers support for Reliable, Unreliable, and reliable encrypted layers. All layers are accessible for UDP transport. Encryption is provided through default AES and RSA encryption implementations.</p> Property Description <code>IOPS</code> Increases the socket's receive rate to match higher transmission rates. A higher value should be set to ensure the read rate keeps pace with the transmission, preventing bottlenecks and ensuring smooth data flow. <code>FPS Update Rate</code> Specifies the frames per second (FPS) update rate provided by the network monitor. This value indicates the frequency of FPS updates. <code>OnTransportSettings</code> Called before Omni starts, allowing for configuration adjustments. Use this to modify Omni settings before initialization, ideally used for setting platform-specific configurations. <p>Tip</p> <p>Example of <code>OnTransportSettings</code>: <pre><code>// inherit from `CustomTransportSettings`\npublic class CustomSettings : CustomTransportSettings\n{\n    public override void OnTransportSettings(TransportSettings transportSettings, RuntimePlatform runtimePlatform)\n    {\n        if(runtimePlatform == RuntimePlatform.Android)\n        {\n            transportSettings.Host = \"89.0.142.86\"; // example\n        }\n    }\n}\n</code></pre></p> <p>Attach this script to your game object, then drag the game object into the <code>OnTransportSettings</code> field.</p> <p>Warning</p> <p>Some options below are transporter-specific, which means certain options are exclusive to transporter X and are not available for transporter Y, but if set they will be ignored.</p> Property Description <code>Use Native Sockets</code> Enables or disables the use of native socket libraries. This property is exclusively available on Windows and Linux platforms. <code>Enable IPV6</code> Enables the usage of IPV6 protocol for network communication. <code>Use Safe MTU</code> Automatically determines the optimal Maximum Transmission Unit (MTU) to reduce packet loss and ensure reliable network communication. This feature adjusts the MTU size to mitigate the risk of packet fragmentation and loss during data transmission. <code>Disconnect Timeout</code> Sets the duration in milliseconds after which the client is automatically disconnected if no packets are received. <code>Packet Pool Size</code> Determines the number of packets available in the packet pool for network communication. <code>Ping Interval</code> Specifies the time interval, in milliseconds, between ping requests to the server for checking the connection status. Longer intervals may reduce network overhead, while shorter intervals offer more frequent connection monitoring. <code>No Delay</code> Activates the TCP No Delay option, reducing latency by disabling Nagle's algorithm. This option can be beneficial for applications requiring immediate data transmission without delay. <code>Linger State</code> Specifies the linger state of the socket. The linger state determines whether the socket will continue to linger after closing, allowing pending data transmissions to complete. <code>Send Buffer Size</code> Specifies the size of the send buffer, optimizing the capacity for outgoing data transmissions. <code>Receive Buffer Size</code> Determines the size of the receive buffer, optimizing the capacity for incoming data transmissions. <code>Send Timeout</code> Sets the duration for the send operation to complete. If the send operation exceeds this duration, it will be aborted. <code>Receive Timeout</code> Specifies the duration for the receive operation to complete. If the receive operation exceeds this duration, it will be aborted, indicating a timeout error. <p>Warning</p> <p>The options below are available for all transporters but may be ignored if set unnecessarily.</p> Property Description <code>Host</code> Specifies the hostname or IP address of the server. This value is used to establish the connection to the server. <code>Server Port</code> Defines the port number used by the server. This value is essential for establishing the connection to the server. <code>Max FPS</code> Sets the maximum frames per second (FPS) for the client. This option does not affect server builds. <code>Max Message Size</code> Specifies the maximum size of messages that the server can receive. This limit ensures efficient handling of data and prevents overload. <code>Max Connections</code> Determines the maximum number of connections that the server can accept concurrently. This limit helps manage server resources effectively."},{"location":"Getting%20Started/installation/#web-server-configuration","title":"Web-Server Configuration","text":"Property Description <code>Enable Web Server</code> Activates the usage of the web server, facilitating web-based interactions with the application. <code>Web Server Port</code> Specifies the port number for the web server, defining the communication channel for web-based interactions. <code>Use Https</code> Enables Secure Sockets Layer (SSL) encryption for secure communication over HTTPS, enhancing data security and integrity. <code>Process PHP</code> Enables the processing of PHP files by the web server, allowing for dynamic content generation and enhanced functionality within web applications."}]}